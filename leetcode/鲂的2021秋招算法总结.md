# DFS

## 全排序类题目

* 有重复必须先排序，并且在循环中判断是否为第一次出现的数

### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

* **没有重复**的数字序列

> 输入: [1,2,3]
> 输出:
> [
>   [1,2,3],
>   [1,3,2],
>   [2,1,3],
>   [2,3,1],
>   [3,1,2],
>   [3,2,1]
> ]

``` java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean st[];

    public void dfs(int[] nums, int u) {
        if (u == nums.length) {
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; ++i) {
            if (!st[i]) {
                path.add(nums[i]);
                st[i] = true;
                dfs(nums, u + 1);
                path.remove(path.size() - 1);
                st[i] = false;
            }
        }
    }

    public List<List<Integer>> permute(int[] nums) {
        st = new boolean[nums.length];
        dfs(nums, 0);
        return ans;
    }
}
```

### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

* 可**包含重复数字**的序列

> ```
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]
> ```

 ```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean st[];

    public void dfs(int[] nums, int u) {
        if (u == nums.length) {
            ans.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; ++i) {
            if (!st[i]) {
                if (i != 0 && nums[i - 1] == nums[i] && !st[i - 1]) continue;
                st[i] = true;
                path.add(nums[i]);
                dfs(nums, u + 1);
                st[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }

    public List<List<Integer>> permuteUnique(int[] nums) {
        Arrays.sort(nums);
        st = new boolean[nums.length];
        dfs(nums, 0);
        return ans;
    }
}
 ```

### [面试题 08.07. 无重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-i-lcci/)

* **无重复字符串**的排列组合

> ```
>  输入：S = "qwe"
>  输出：["qwe", "qew", "wqe", "weq", "ewq", "eqw"]
> ```

```java
class Solution {
    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    boolean st[];

    public void dfs(char[] str, int u) {
        int n = str.length;
        if (u == n) {
            ans.add(sb.toString());
            return;        
        }
        for (int i = 0; i < n; ++i) {
            if (!st[i]) {
                sb.append(str[i]);
                st[i] = true;
                dfs(str, u + 1);
                st[i] = false;
                sb.deleteCharAt(sb.length() - 1);
            }
        }
    }

    public String[] permutation(String S) {
        st = new boolean[S.length()];
        dfs(S.toCharArray(), 0);
        String[] res = new String[ans.size()];
        for (int i = 0; i < ans.size(); ++i) res[i] = ans.get(i);
        return res;
    }
}
```

### [面试题 08.08. 有重复字符串的排列组合](https://leetcode-cn.com/problems/permutation-ii-lcci/)

* **有重复字符串**的排列组合

> ```
>  输入：S = "qqe"
>  输出：["eqq","qeq","qqe"]
> ```

```java
class Solution {
    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();
    boolean st[];

    public void dfs(char[] str, int u) {
        int n = str.length;
        if (u == n) {
            ans.add(sb.toString());
            return;
        }
        for (int i = 0; i < n; ++i) {
            if (!st[i]) {
                if (i != 0 && str[i] == str[i - 1] && !st[i - 1]) continue;
                sb.append(str[i]);
                st[i] = true;
                dfs(str, u + 1);
                st[i] = false;
                sb.deleteCharAt(sb.length() - 1);
            }
        }
    }

    public String[] permutation(String S) {
        char[] str = S.toCharArray();
        Arrays.sort(str);
        st = new boolean[S.length()];
        dfs(str, 0);
        String[] res = new String[ans.size()];
        for (int i = 0; i < ans.size(); ++i) res[i] = ans.get(i);
        return res;
    }
}
```

### [60. 排列序列](https://leetcode-cn.com/problems/permutation-sequence/)

* 第k个全排列序列

> ```
> 输入：n = 3, k = 3
> 输出："213"
> 
> _ _ _ 
> 一共三个位置，若第一个位置填1，则后面一共有(n - 1)!种即2种，小于k；
> 		    若第一个位置填2，则后面同样有2种，已经超过k，则第一个数字为2。
> ```

```java
class Solution {
    public String getPermutation(int n, int k) {
        String ans = "";
        boolean st[] = new boolean[10];
        for (int i = 0; i < n; ++i) {
            int fact = 1;
            for (int j = 1; j <= n - i - 1; ++j) fact *= j;
            for (int j = 1; j <= n; ++j) {
                if (!st[j]) {
                    if (fact < k) k -= fact;
                    else {
                        ans += Integer.toString(j);
                        st[j] = true;
                        break;
                    }
                }
            }
        }
        return ans;
    }
}
```

### [784. 字母大小写全排列](https://leetcode-cn.com/problems/letter-case-permutation/)

* 大小写转换

> ```
> 输入：S = "a1b2"
> 输出：["a1b2", "a1B2", "A1b2", "A1B2"]
> ```

```java
class Solution {
    List<String> ans = new ArrayList<>();
    public List<String> letterCasePermutation(String S) {
        dfs(S.toCharArray(), 0);
        return ans;
    }

    public void dfs(char s[], int u) {
        if (u == s.length) {
            ans.add(new String(s));
            return;
        }
        dfs(s, u + 1);
        if (Character.isLetter(s[u])) {
            s[u] ^= 32;
            dfs(s, u + 1);
            s[u] ^= 32;
        }
    }
}
```

## 组合类题目

### [17. 电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

```java
class Solution {
    Map<Character, String> map = new HashMap<Character, String>() {{
        put('2', "abc");
        put('3', "def");
        put('4', "ghi");
        put('5', "jkl");
        put('6', "mno");
        put('7', "pqrs");
        put('8', "tuv");
        put('9', "wxyz");
    }};
    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();

    public void dfs(char[] s, int u) {
        int n = s.length;
        if (u == n) {
            ans.add(sb.toString());
            return;
        }
        String str = map.get(s[u]);
        for (int i = 0; i < str.length(); ++i) {
            sb.append(str.charAt(i));
            dfs(s, u + 1);
            sb.deleteCharAt(sb.length() - 1);
        }
    }

    public List<String> letterCombinations(String digits) {
        if (digits.equals("")) return new ArrayList<String>();
        dfs(digits.toCharArray(), 0);
        return ans;
    } 
}
```

### [77. 组合](https://leetcode-cn.com/problems/combinations/)

> ```
> 输入: n = 4, k = 2
> 输出:
> [
>   [2,4],
>   [3,4],
>   [2,3],
>   [1,2],
>   [1,3],
>   [1,4],
> ]
> ```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void dfs(int n, int k, int u) {
        // 剪枝
        if (path.size() + (n - u + 1) < k) return;
        if (path.size() == k) {
            ans.add(new ArrayList<Integer>(path));
            return;
        }
        path.add(u);
        dfs(n, k, u + 1);
        path.remove(path.size() - 1);
        dfs(n, k, u + 1);
    }

    public List<List<Integer>> combine(int n, int k) {
        dfs(n, k, 1);
        return ans;
    }
}
```

### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

* 无重复数字且可以重复使用

> ```
> 输入：candidates = [2,3,6,7], target = 7,
> 所求解集为：
> [
>   [7],
>   [2,2,3]
> ]
> ```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void dfs(int[] nums, int target, int u) {
        int n = nums.length;
        if (target == 0) {
            ans.add(new ArrayList<>(path));
            return;
        }
        if (u == n) return;
        for (int i = 0; nums[u] * i <= target; ++i) {
            dfs(nums, target - nums[u] * i, u + 1);
            path.add(nums[u]);
        }
        for (int i = 0; nums[u] * i <= target; ++i) path.remove(path.size() - 1);
    }

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        dfs(candidates, target, 0);
        return ans;
    }
}
```

### [40. 组合总和 II](https://leetcode-cn.com/problems/combination-sum-ii/)

* 数字可重复且只能用一次

> ```
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 所求解集为:
> [
>   [1, 7],
>   [1, 2, 5],
>   [2, 6],
>   [1, 1, 6]
> ]
> ```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void dfs(int[] nums, int target, int u) {
        int n = nums.length;
        if (target == 0) {
            ans.add(new ArrayList<>(path));
            return;
        }
        if (u == n) return;

        int k = u + 1;
        while (k < n && nums[k] == nums[u]) k++;
        int cnt = k - u;

        for (int i = 0; nums[u] * i <= target && i <= cnt; ++i) {
            dfs(nums, target - nums[u] * i, k);
            path.add(nums[u]);
        }
        for (int i = 0; nums[u] * i <= target && i <= cnt; ++i) path.remove(path.size() - 1);
    }

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        dfs(candidates, target, 0);
        return ans;
    }
}
```

### [216. 组合总和 III](https://leetcode-cn.com/problems/combination-sum-iii/)

* 1-9 九个数字选取k个数，不能重复使用

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int len = 9;

    public void dfs(int k, int target, int u, int sum) {
        if (path.size() + (len - u + 1) < k || path.size() > k) return;
        if (target == sum && path.size() == k) {
            ans.add(new ArrayList<>(path));
            return;
        }
        path.add(u);
        sum += u;
        dfs(k, target, u + 1, sum);
        path.remove(path.size() - 1);
        sum -= u;
        dfs(k, target, u + 1, sum);
    }

    public List<List<Integer>> combinationSum3(int k, int n) {
        dfs(k, n, 1, 0);
        return ans;
    }
}
```

### [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

* 非DFS问题
* f[j] 表示总和为j的所有方案数

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int n = nums.length;
        int[] f = new int[target + 1];
        f[0] = 1;
        for (int j = 0; j <= target; ++j) {
            for (int x: nums) {
                if (j >= x) f[j] += f[j - x];
            }
        }
        return f[target];
    }
}
```

## 子集类题目

### [78. 子集](https://leetcode-cn.com/problems/subsets/)

> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```

```java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> ans = new ArrayList<>();
        int n = nums.length;
        for (int i = 0; i < 1 << n; ++i) {
            List<Integer> path = new ArrayList<>();
            for (int j = 0; j < n; ++j) {
                if ((i >> j & 1) == 1) path.add(nums[j]);
            }
            ans.add(path);
        }
        return ans;
    }
}
```

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public void dfs(int[] nums, int u) {
        if (u == nums.length) {
            ans.add(new ArrayList<>(path));
            return;
        }
        path.add(nums[u]);
        dfs(nums, u + 1);
        path.remove(path.size() - 1);
        dfs(nums, u + 1);
    }

    public List<List<Integer>> subsets(int[] nums) {
        dfs(nums, 0);
        return ans;
    }
}
```

### [90. 子集 II](https://leetcode-cn.com/problems/subsets-ii/)

> ```
> 输入：nums = [1,2,2]
> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
> ```

```java
class Solution {
    private List<List<Integer>> ans = new ArrayList<>();
    private boolean[] st;

    public void dfs(int u, int[] nums) {
        int n = nums.length;
        if (u == n) {
            List<Integer> path = new ArrayList<>();
            for (int i = 0; i < n; ++i) {
                if (st[i]) path.add(nums[i]);
            }
            ans.add(path);
            return;
        }
        int k = u;
        while (k < n && nums[k]== nums[u]) k++;
        dfs(k, nums);

        for (int i = u; i < k; ++i) {
            st[i] = true;
            dfs(k, nums);
        }

        for (int i = u; i < k; ++i) st[i] = false;
    }

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        st = new boolean[nums.length];
        Arrays.sort(nums);
        dfs(0, nums);
        return ans;
    }
}
```

## 单词搜索类题目

### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true
>
> ![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```java
class Solution {
    int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};

    public boolean dfs(char[][] board, String word, int u, int x, int y) {
        if (board[x][y] != word.charAt(u)) return false;
        if (u == word.length() - 1) return true;

        char t = board[x][y];
        board[x][y] = '.';
        for (int i = 0; i < 4; ++i) {
            int a = x + dx[i], b = y + dy[i];
            if (a < 0 || a >= board.length || b < 0 || b >= board[0].length || board[a][b] == '.') continue;
            if (dfs(board, word, u + 1, a, b)) return true;
        }
        board[x][y] = t;
        return false;
    }

    public boolean exist(char[][] board, String word) {
        int n = board.length;
        if (n == 0) return false;
        int m = board[0].length;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (dfs(board, word, 0, i, j)) return true;
            }
        }
        return false;
    }
}
```

### [212. 单词搜索 II](https://leetcode-cn.com/problems/word-search-ii/)

> 输入：board = [["o","a","a","n"],["e","t","a","e"],["i","h","k","r"],["i","f","l","v"]], words = ["oath","pea","eat","rain"]
> 输出：["eat","oath"]
>
> ![img](https://assets.leetcode.com/uploads/2020/11/07/search1.jpg)

```java
class Solution {
    class Node {
        Node son[];
        int id;
        public Node() {
            id = -1;
            son = new Node[26];
        }
    }

    Node root = new Node();
    public void insert(String word, int id) {
        Node cur = root;
        for (char c: word.toCharArray()) {
            int u = c - 'a';
            if (cur.son[u] == null) cur.son[u] = new Node();
            cur = cur.son[u];
        }
        cur.id = id; 
    }

    int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
    Set<Integer> ids = new HashSet<>();
    public void dfs(char[][] board, int x, int y, Node cur) {
        if (cur.id != -1) ids.add(cur.id);
        char t = board[x][y];
        board[x][y] = '.';
        for (int i = 0; i < 4; ++i) {
            int a = x + dx[i], b = y + dy[i];
            if (a < 0 || a >= board.length || b < 0 || b >= board[0].length || board[a][b] == '.') continue;
            int u = board[a][b] - 'a';
            if (cur.son[u] != null) dfs(board, a, b, cur.son[u]);
        }
        board[x][y] = t;
    }

    public List<String> findWords(char[][] board, String[] words) {
        for (int i = 0; i < words.length; ++i) insert(words[i], i);
        for (int i = 0; i < board.length; ++i) {
            for (int j = 0; j < board[i].length; ++j) {
                int u = board[i][j] - 'a';
                if (root.son[u] != null) dfs(board, i, j, root.son[u]);
            }
        }
        List<String> ans = new ArrayList<>();
        for (Integer id: ids) ans.add(words[id]);
        return ans;
    }
}
```

# BFS

## 网格类题目

### [130. 被围绕的区域](https://leetcode-cn.com/problems/surrounded-regions/)

> ```
> 输入: board = [["X","X","X","X"],["X","O","O","X"],["X","X","O","X"],["X","O","X","X"]]
> 输出：[["X","X","X","X"],["X","X","X","X"],["X","X","X","X"],["X","O","X","X"]]
> 解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 'O' 都不会被填充为 'X'。 任何不在边界上，或不与边界上的 'O' 相连的 'O' 最终都会被填充为 'X'。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg)

```java
class Solution {
    public void solve(char[][] board) {
        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        int n = board.length;
        if (n == 0) return;
        int m = board[0].length;
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < n; ++i) {
            if (board[i][0] == 'O') queue.offer(new int[]{i, 0});
            if (board[i][m - 1] == 'O') queue.offer(new int[]{i, m - 1});
        }
        for (int i = 1; i < m - 1; ++i) {
            if (board[0][i] == 'O') queue.offer(new int[]{0, i});
            if (board[n - 1][i] == 'O') queue.offer(new int[]{n - 1, i});
        }
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0], y = t[1];
            board[x][y] = '.';
            for (int i = 0; i < 4; ++i) {
                int a = x + dx[i], b = y + dy[i];
                if (a < 0 || a >= n || b < 0 || b >= m || board[a][b] != 'O') continue;
                queue.offer(new int[]{a, b});
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (board[i][j] == '.') board[i][j] = 'O';
                else if (board[i][j] == 'O') board[i][j] = 'X';
            }
        }
    }
}
```

### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

> ```
> 输入：grid = [
>       ["1","1","1","1","0"],
>       ["1","1","0","1","0"],
>       ["1","1","0","0","0"],
>       ["0","0","0","0","0"]
>     ]
> 输出：1
> ```

```java
class Solution {
    public int numIslands(char[][] grid) {
        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        int n = grid.length;
        if (n == 0) return 0;
        int m = grid[0].length;
        int ans = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == '1') {
                    ++ans;
                    grid[i][j] = '0';
                    Queue<int[]> queue = new LinkedList<>();
                    queue.offer(new int[]{i, j});
                    while (!queue.isEmpty()) {
                        int[] t = queue.poll();
                        int x = t[0], y = t[1];
                        for (int k = 0; k < 4; ++k) {
                            int a = x + dx[k], b = y + dy[k];
                            if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == '0') continue;
                            queue.offer(new int[]{a, b});
                            grid[a][b] = '0';
                        }
                    }
                }
            }
        }
        return ans;
    }
}
```

### [695. 岛屿的最大面积](https://leetcode-cn.com/problems/max-area-of-island/)

> ```
> 输入：[[0,0,1,0,0,0,0,1,0,0,0,0,0],
>      [0,0,0,0,0,0,0,1,1,1,0,0,0],
>      [0,1,1,0,1,0,0,0,0,0,0,0,0],
>      [0,1,0,0,1,1,0,0,1,0,1,0,0],
>      [0,1,0,0,1,1,0,0,1,1,1,0,0],
>      [0,0,0,0,0,0,0,0,0,0,1,0,0],
>      [0,0,0,0,0,0,0,1,1,1,0,0,0],
>      [0,0,0,0,0,0,0,1,1,0,0,0,0]]
> 
> 输出：6
> ```
>
> ![](https://i.loli.net/2021/04/19/xOSNjQzv84dkmpr.png)

```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        int n = grid.length;
        if (n == 0) return 0;
        int m = grid[0].length;
        int ans = 0;

        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    grid[i][j] = 0;
                    Queue<int[]> queue = new LinkedList<>();
                    queue.offer(new int[]{i, j});
                    int tmp = 0;
                    while (!queue.isEmpty()) {
                        int[] t = queue.poll();
                        int x = t[0], y = t[1];
                        tmp++;
                        for (int k = 0; k < 4; ++k) {
                            int a = x + dx[k], b = y + dy[k];
                            if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] == 0) continue;
                            queue.offer(new int[]{a, b});
                            grid[a][b] = 0;
                        }
                    }
                    ans = Math.max(ans, tmp);
                }
            }
        }
        return ans;
    }
}
```

### [面试题 16.19. 水域大小](https://leetcode-cn.com/problems/pond-sizes-lcci/)

> ```
> 输入：
> [
>   [0,2,1,0],
>   [0,1,0,1],
>   [1,1,0,1],
>   [0,1,0,1]
> ]
> 输出： [1,2,4]
> ```

* 此题与上面的题目不同，需要判断周围8个点的坐标，而不是上下左右四个。

```java
class Solution {
    public int[] pondSizes(int[][] land) {
        int n = land.length;
        if (n == 0) return new int[]{};
        int m = land[0].length;
        List<Integer> ans = new ArrayList<>();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (land[i][j] == 0) {
                    int tmp = 0;
                    land[i][j] = 1;
                    Queue<int[]> queue = new LinkedList<>();
                    queue.offer(new int[]{i, j});
                    while (!queue.isEmpty()) {
                        int[] t = queue.poll();
                        int x = t[0], y = t[1];
                        tmp++;
                        for (int k1 = x - 1; k1 <= x + 1; ++k1) {
                            for (int k2 = y - 1; k2 <= y + 1; ++k2) {
                                if (k1 == x && k2 == y) continue;
                                if (k1 < 0 || k1 >= n || k2 < 0 || k2 >= m || land[k1][k2] != 0) continue;
                                land[k1][k2] = 1;
                                queue.offer(new int[]{k1, k2});
                            }
                        }
                    }
                    ans.add(tmp);
                }
            }
        }
        int[] res = ans.stream().mapToInt(Integer::valueOf).toArray();
        Arrays.sort(res);
        return res;
    }
}
```

### [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/)

> ```
> 输入：[[1,0,1],
> 	  [0,0,0],
> 	  [1,0,1]]
> 输出：2
> 解释： 
> 海洋单元格 (1, 1) 和所有陆地单元格之间的距离都达到最大，最大距离为 2
> ```

```java
class Solution {
    public int maxDistance(int[][] grid) {
        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        int n = grid.length;
        if (n == 0) return 0;
        int m = grid[0].length;
        int ans = -1;
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) queue.offer(new int[]{i, j});
            }
        }
        if (queue.size() == n * n) return -1;
        while (!queue.isEmpty()) {
            ans++;
            int size = queue.size();
            while (size-- > 0) {
                int[] t = queue.poll();
                int x = t[0], y = t[1];
                for (int i = 0; i < 4; ++i) {
                    int a = x + dx[i], b = y + dy[i];
                    if (a < 0 || a >= n || b < 0 || b >= m || grid[a][b] != 0) continue;
                    queue.offer(new int[]{a, b});
                    grid[a][b] = 2;
                }
            }
        }
        return ans;
    }
}
```

### [994. 腐烂的橘子](https://leetcode-cn.com/problems/rotting-oranges/)

> ```
> 输入：[[2,1,1],[1,1,0],[0,1,1]]
> 输出：4
> ```

```java
class Solution {
    public int orangesRotting(int[][] grid) {
        int n = grid.length;
        if (n == 0) return 0;
        int m = grid[0].length;
        int ans = 0, cnt = 0;
        Queue<int[]> queue = new LinkedList<>();
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 2) queue.offer(new int[]{i, j});
                else if (grid[i][j] == 1) cnt++;
            }
        }

        if (cnt == 0) return 0;

        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        while (!queue.isEmpty()) {
            ans++;
            int size = queue.size();
            while (size-- > 0) {
                int[] t = queue.poll();
                int x = t[0], y = t[1];
                for (int i = 0; i < 4; ++i) {
                    int a = x + dx[i], b = y + dy[i];
                    if (a >= 0 && a < n && b >= 0 && b < m && grid[a][b] == 1) {
                        cnt--;
                        grid[a][b] = 2;
                        queue.offer(new int[]{a, b});
                    }
                }
            }
        }
        return cnt == 0 ? ans - 1 : -1;
    }
}
```

## 课程表类题目

### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

> ```
> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：true
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
> ```

````java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] indegrees = new int[numCourses];
        List<List<Integer>> adjacency = new ArrayList<>();
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) adjacency.add(new ArrayList<>());
        for (int[] pre: prerequisites) {
            indegrees[pre[0]]++;
            adjacency.get(pre[1]).add(pre[0]);
        } 

        for (int i = 0; i < numCourses; ++i) {
            if (indegrees[i] == 0) queue.offer(i);
        }
        while (!queue.isEmpty()) {
            int t = queue.poll();
            numCourses--;
            for (int cur: adjacency.get(t)) {
                if (--indegrees[cur] == 0) queue.offer(cur);
            }
        }
        return numCourses == 0;
    }
}
````

### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

> ```
> 输入: 4, [[1,0],[2,0],[3,1],[3,2]]
> 输出: [0,1,2,3] or [0,2,1,3]
> 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
>      因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
> ```

```java
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        int[] indegrees = new int[numCourses];
        for (int[] pre: prerequisites) indegrees[pre[0]]++;
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < numCourses; ++i) {
            if (indegrees[i] == 0) queue.offer(i);
        }
        int cnt = 0;
        int[] ans = new int[numCourses];
        while (!queue.isEmpty()) {
            int t = queue.poll();
            ans[cnt++] = t;
            for (int[] cur: prerequisites)  {
                if (cur[1] == t && --indegrees[cur[0]] == 0) queue.offer(cur[0]);
            }
        }
        if (cnt == numCourses) return ans;
        return new int[0];
    }
}
```

## 染色类

### [733. 图像渲染](https://leetcode-cn.com/problems/flood-fill/)

> ```
> 输入: 
>     image = [[1,1,1],[1,1,0],[1,0,1]]
>     sr = 1, sc = 1, newColor = 2
> 输出: [[2,2,2],[2,2,0],[2,0,1]]
> 解析: 
>     在图像的正中间，(坐标(sr,sc)=(1,1)),
>     在路径上所有符合条件的像素点的颜色都被更改成2。
>     注意，右下角的像素没有更改为2，
>     因为它不是在上下左右四个方向上与初始点相连的像素点。
> ```

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        int n = image.length;
        if (n == 0) return image;
        int m = image[0].length;
        int c = image[sr][sc];
        if (c == newColor) return image;

        Queue<int[]> queue = new LinkedList<>();
        queue.offer(new int[]{sr, sc});
        image[sr][sc] = newColor;
        while (!queue.isEmpty()) {
            int[] t = queue.poll();
            int x = t[0], y = t[1];
            for (int i = 0; i < 4; ++i) {
                int a = x + dx[i], b = y + dy[i];
                if (a < 0 || a >= n || b < 0 || b >= m || image[a][b] != c) continue;
                image[a][b] = newColor;
                queue.offer(new int[]{a, b});
            }
        }
        return image;
    }
}
```

### [1042. 不邻接植花](https://leetcode-cn.com/problems/flower-planting-with-no-adjacent/)

> ```
> 输入：n = 3, paths = [[1,2],[2,3],[3,1]]
> 输出：[1,2,3]
> 解释：
> 花园 1 和 2 花的种类不同。
> 花园 2 和 3 花的种类不同。
> 花园 3 和 1 花的种类不同。
> 因此，[1,2,3] 是一个满足题意的答案。其他满足题意的答案有 [1,2,4]、[1,4,2] 和 [3,2,1]
> ```

```java
class Solution {
    public int[] gardenNoAdj(int n, int[][] paths) {
        int[] ans = new int[n];
        List<List<Integer>> adjacency = new ArrayList<>();
        for (int i = 0; i <= n; ++i) adjacency.add(new ArrayList<>());
        for (int[] cur: paths) {
            adjacency.get(cur[0]).add(cur[1]);
            adjacency.get(cur[1]).add(cur[0]);
        }
        for (int i = 1; i <= n; ++i) {
            boolean[] color = new boolean[5];
            for (int id: adjacency.get(i)) color[ans[id - 1]] = true;
            for (int j = 1; j <= 4; ++j) {
                if (!color[j]) {
                    ans[i - 1] = j;
                    break;
                }
            }
        }
        return ans;
    }
}
```

# 链表

## 链表基础

### 自定义链表

```java
public class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) {this.val = val;}
    ListNode(int val, ListNode next) {this.val = val; this.next = next;}
} 
```

### 生成链表

```java
    public static ListNode createList(int[] nums) {
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        for (int num: nums) {
            cur = cur.next = new ListNode(num);
        }
        return dummy.next;
    }

    public static ListNode createRandomList(int n) {
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        Random random = new Random();
        while (n-- > 0){
            cur = cur.next = new ListNode(random.nextInt() % 1001);
        }
        return dummy.next;
    }
```

### 输出链表

```java
    public static void printList(ListNode head) {
        while (head != null) {
            if (head.next != null) System.out.print(head.val + "->");
            else System.out.print(head.val);
            head = head.next;
        }
        System.out.println();
    }
    @Override
    public String toString() {
        ListNode cur = this;
        StringBuilder sb = new StringBuilder();
        while (cur != null) {
            sb.append(cur.val);
            if (cur.next != null) sb.append("->");
            cur = cur.next;
        }
        return sb.toString();
    }

```

## 加法题

### [2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

> ```
> 输入：l1 = [2,4,3], l2 = [5,6,4]
> 输出：[7,0,8]
> 解释：342 + 465 = 807.
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        int c = 0;
        while (l1 != null || l2 != null) {
            int a = l1 == null ? 0 : l1.val;
            int b = l2 == null ? 0 : l2.val;
            int t = a + b + c;
            cur = cur.next = new ListNode(t % 10);
            c = t / 10;
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        if (c == 1) cur.next = new ListNode(1);
        return dummy.next;
    }
}
```

### [445. 两数相加 II](https://leetcode-cn.com/problems/add-two-numbers-ii/)

> ```
> 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
> 输出：7 -> 8 -> 0 -> 7
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        Stack<Integer> s1 = new Stack<>();
        Stack<Integer> s2 = new Stack<>();      
        while (l1 != null) {
            s1.push(l1.val);
            l1 = l1.next;
        }
        while (l2 != null) {
            s2.push(l2.val);
            l2 = l2.next;
        }
        ListNode cur = null;
        int c = 0;
        while (!s1.isEmpty() || !s2.isEmpty() || c != 0) {
            int a = s1.isEmpty() ? 0 : s1.pop();
            int b = s2.isEmpty() ? 0 : s2.pop();

            int t = a + b + c;
            c = t / 10; 
            ListNode tmp = new ListNode(t % 10);
            tmp.next = cur;
            cur = tmp;
        }
        return cur;
    }
}
```

## 翻转链表类

### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

> ```
> 输入: 1->2->3->4->5->NULL
> 输出: 5->4->3->2->1->NULL
> ```

````java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, prev = null;
        while (cur != null) {
            ListNode next = cur.next;
            cur.next = prev;
            prev = cur;
            cur = next;
        }
        return prev;
    }
}
````

### [92. 反转链表 II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)

> ```
> 输入：head = [1,2,3,4,5], left = 2, right = 4
> 输出：[1,4,3,2,5]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode a = dummy;
        for (int i = 0; i < left - 1; ++i) a = a.next;
        ListNode b = a.next, c = b.next;
        int k = right - left;
        while (k-- > 0) {
            ListNode t = c.next;
            c.next = b;
            b = c;
            c = t;
        }
        a.next.next = c;
        a.next = b;
        return dummy.next;
    }
}
```

### [剑指 Offer 06. 从尾到头打印链表](https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/)

> ```
> 输入：head = [1,3,2]
> 输出：[2,3,1]
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] reversePrint(ListNode head) {
        if (head == null) return new int[]{};
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode a = dummy;
        ListNode b = a.next, c = b.next;
        while (c != null && b != null) {
            ListNode t = c.next;
            c.next = b;
            b = c;
            c = t; 
        }  
        a.next.next = c;
        a.next = b; 
        List<Integer> ans = new ArrayList<>();
        for (ListNode p = dummy.next; p != null; p = p.next) {
            ans.add(p.val);
        }
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

### [143. 重排链表](https://leetcode-cn.com/problems/reorder-list/)

> ```
> 给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public void reorderList(ListNode head) {
        if (head == null) return;
        int n = 0;
        for (ListNode p = head; p != null; p = p.next) n++;
        ListNode mid = head;
        for (int i = 0; i < (n + 1) / 2 - 1; ++i) mid = mid.next;
        ListNode a = mid, b = a.next;
        for (int i = 0; i < n / 2; ++i) {
            ListNode c = b.next;
            b.next = a;
            a = b;
            b = c;
        }
        ListNode p = head, q = a;
        for (int i = 0; i < n / 2; ++i) {
            ListNode o = q.next;
            q.next = p.next;
            p.next = q;
            p = q.next;
            q = o;
        }
        if (n % 2 == 1) mid.next = null;
        else mid.next.next = null;
    }
}
```

### [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)

> ```
> 输入：head = [1,2,3,4,5], k = 2
> 输出：[2,1,4,3,5]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode p = dummy;
        while (p != null) {
            ListNode q = p;
            for (int i = 0; i < k && q != null; ++i) q = q.next;
            if (q == null) break;
            ListNode a = p.next, b = a.next;
            for (int i = 0; i < k - 1; ++i) {
                ListNode c = b.next;
                b.next = a;
                a = b;
                b = c;
            }
            ListNode t = p.next;
            p.next = a;
            t.next = b;
            p = t;
        }
        return dummy.next;
    }
}
```

### [234. 回文链表](https://leetcode-cn.com/problems/palindrome-linked-list/)

> ```
> 输入: 1->2->2->1
> 输出: true
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public boolean isPalindrome(ListNode head) {
        int n = 0;
        for (ListNode p = head; p != null; p = p.next) n++;
        if (n == 1) return true;
        ListNode a = head;
        for (int i = 0; i < (n + 1) / 2; ++i) a = a.next;
        ListNode b = a.next;
        for (int i = 0; i < n / 2 - 1; ++i) {
            ListNode c = b.next;
            b.next = a;
            a = b;
            b = c;
        }
        ListNode p = head, q = a;
        for (int i = 0; i < n / 2; ++i) {
            if (p.val != q.val) return false;
            p = p.next;
            q = q.next;
        }
        return true;
    }
}
```

## 相交链表类

### [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)

> ```
> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
> 输出：Reference of the node with value = 8
> 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
> ```
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_1.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A  = headA, B = headB;
        while (A != B) {
            A = A == null ? headB : A.next;
            B = B == null ? headA : B.next;
        }
        return A;
    }
}
```

### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：true
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null) return false;
        ListNode slow = head, fast = head.next;
        while (slow != fast) {
            if (fast == null || fast.next == null) return false;
            slow = slow.next;
            fast = fast.next.next;
        }
        return true;
    }
}
```

### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

> ```
> 输入：head = [3,2,0,-4], pos = 1
> 输出：返回索引为 1 的链表节点
> 解释：链表中有一个环，其尾部连接到第二个节点。
> ```
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) {
 *         val = x;
 *         next = null;
 *     }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        if (head == null) return head;
        ListNode s = head, f = head.next;
        while (s != f) {
            if (f == null || f.next == null) return null;
            s = s.next;
            f = f.next.next;
        }
        s = head;
        f = f.next;
        while (s != f) {
            s = s.next;
            f = f.next;
        }
        return f;
    }
}
```

### [剑指 Offer 22. 链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

> ```
> 给定一个链表: 1->2->3->4->5, 和 k = 2.
> 返回链表 4->5.
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode getKthFromEnd(ListNode head, int k) {
        ListNode l1 = head, l2 = head;
        while (k-- > 0) l1 = l1.next;
        while (l1 != null) {
            l1 = l1.next;
            l2 = l2.next;
        }
        return l2;
    }
}
```

## 链表删除

### [剑指 Offer 18. 删除链表的节点](https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/)

> ```
> 输入: head = [4,5,1,9], val = 5
> 输出: [4,1,9]
> 解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode deleteNode(ListNode head, int val) {
        if (head.val == val) return head.next;
        for (ListNode p = head; p != null; p = p.next) {
            if (p.next != null && p.next.val == val) {
                p.next = p.next.next;
            }
        }
        return head;
    }
}
```

### [237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)

> ```
> 输入：head = [4,5,1,9], node = 5
> 输出：[4,1,9]
> 解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -> 1 -> 9.
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val = node.next.val;
        node.next = node.next.next;
    }
}
```

### [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

> ```
> 输入：head = [1,2,3,4,5], n = 2
> 输出：[1,2,3,5]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode l1 = dummy, l2 = dummy;
        while (n-- >= 0) l1 = l1.next;
        while (l1 != null) {
            l1 = l1.next;
            l2 = l2.next;
        }
        l2.next = l2.next.next;
        return dummy.next;
    }
}
```

### [83. 删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/)

> ```
> 输入：head = [1,1,2,3,3]
> 输出：[1,2,3]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/list2.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) return head;
        ListNode cur = head;
        for (ListNode p = head.next; p != null; p = p.next) {
            if (p.val != cur.val) cur = cur.next = p;
        }
        cur.next = null;
        return head;
    }
}
```

### [82. 删除排序链表中的重复元素 II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/)

> ```
> 输入：head = [1,2,3,3,4,4,5]
> 输出：[1,2,5]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/linkedlist1.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode p = dummy;
        while (p.next != null) {
            ListNode q = p.next.next;
            while (q != null && q.val == p.next.val) q = q.next;
            if (p.next.next == q) p = p.next;
            else p.next = q;
        }
        return dummy.next;
    }
}
```

### [面试题 02.01. 移除重复节点](https://leetcode-cn.com/problems/remove-duplicate-node-lcci/)

> ```
>  输入：[1, 2, 3, 3, 2, 1]
>  输出：[1, 2, 3]
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode removeDuplicateNodes(ListNode head) {
        if (head == null) return head;
        Set<Integer> set = new HashSet<>();
        set.add(head.val);

        ListNode cur = head;
        while (cur.next != null) {
            ListNode p = cur.next;
            if (set.add(p.val)) cur = cur.next;
            else cur.next = cur.next.next;
        }
        cur.next = null;
        return head;
    }
}
```

### [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)

> ```
> 输入：head = [1,2,6,3,4,5,6], val = 6
> 输出：[1,2,3,4,5]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        ListNode dummy = new ListNode(-1);
        dummy.next = head;
        ListNode prev = dummy, cur = head;
        while (cur != null) {
            if (cur.val == val) prev.next = cur.next;
            else prev = cur;
            cur = cur.next;
        } 
        return dummy.next;
    }
}
```

## 链表排序

### [147. 对链表进行插入排序](https://leetcode-cn.com/problems/insertion-sort-list/)

> ```
> 输入: 4->2->1->3
> 输出: 1->2->3->4
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode insertionSortList(ListNode head) {
        ListNode dummy = new ListNode(-1);
        ListNode p = head;
        while (p != null) {
            ListNode cur = dummy, next = p.next;
            while (cur.next != null && cur.next.val <= p.val) cur = cur.next;
            p.next = cur.next;
            cur.next = p;
            p = next;
        }
        return dummy.next;
    }
}
```

### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

> ```
> 输入：head = [4,2,1,3]
> 输出：[1,2,3,4]
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode sortList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode s = head, f = head;
        while (f.next != null && f.next.next != null) {
            s = s.next;
            f = f.next.next;
        }
        f = s;
        s = s.next;
        f.next = null;
        return merge(sortList(head), sortList(s));
    }

    public ListNode merge(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) return l1 == null ? l2 : l1;
        ListNode dummy = new ListNode(-1), cur = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 != null) cur.next = l1;
        if (l2 != null) cur.next = l2;
        return dummy.next;
    }
}
```

##  合并链表

### [21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

> ```
> 输入：l1 = [1,2,4], l2 = [1,3,4]
> 输出：[1,1,2,3,4,4]
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) return l1 == null ? l2 : l1;
        ListNode dummy = new ListNode(-1), cur = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 != null) cur.next = l1;
        if (l2 != null) cur.next = l2;
        return dummy.next;
    }
}
```

### [1669. 合并两个链表](https://leetcode-cn.com/problems/merge-in-between-linked-lists/)

> ```
> 输入：list1 = [0,1,2,3,4,5], a = 3, b = 4, list2 = [1000000,1000001,1000002]
> 输出：[0,1,2,1000000,1000001,1000002,5]
> 解释：我们删除 list1 中第三和第四个节点，并将 list2 接在该位置。上图中蓝色的边和节点为答案链表。
> ```
>
> ![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/28/merge_linked_list_ex1.png)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeInBetween(ListNode list1, int a, int b, ListNode list2) {
        ListNode cur = list1;
        ListNode begin = null, end = null;
        int cnt = 0;
        while (cur != null) {
            if (cnt == a - 1) begin = cur;
            else if (cnt == b) {
                end = cur;
                break;
            }
            cur = cur.next;
            cnt++;
        }
        begin.next = list2;
        cur = list2;
        while (cur.next != null) {
            cur = cur.next;
        }
        cur.next = end.next;
        return list1;
    }
}
```

### [23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

> ```
> 输入：lists = [[1,4,5],[1,3,4],[2,6]]
> 输出：[1,1,2,3,4,4,5,6]
> 解释：链表数组如下：
>     [
>       1->4->5,
>       1->3->4,
>       2->6
>     ]
> 将它们合并到一个有序链表中得到。
> 1->1->2->3->4->4->5->6
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int l, int r) {
        if (l == r) return lists[l];
        if (l > r) return null;
        int mid = l + r >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        if (l1 == null || l2 == null) return l1 == null ? l2 : l1;
        ListNode dummy = new ListNode(-1);
        ListNode cur = dummy;
        while (l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                cur.next = l2;
                l2 = l2.next;
            }
            cur = cur.next;
        }
        if (l1 == null) cur.next = l2;
        if (l2 == null) cur.next = l1;
        return dummy.next;
    }
}
```

## 分隔链表

### [86. 分隔链表](https://leetcode-cn.com/problems/partition-list/)

> ```
> 输入：head = [1,4,3,2,5,2], x = 3
> 输出：[1,2,2,4,3,5]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/01/04/partition.jpg)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode partition(ListNode head, int x) {
        ListNode l1 = new ListNode(-1), l2 = new ListNode(-1);
        ListNode cur1 = l1, cur2 = l2, p = head;
        while (p != null) {
            if (p.val < x) cur1 = cur1.next = p;
            else cur2 = cur2.next = p;
            p = p.next;
        }
        cur2.next = null;
        cur1.next = l2.next;
        return l1.next;
    }
}
```

### [725. 分隔链表](https://leetcode-cn.com/problems/split-linked-list-in-parts/)

> ```
> 输入: 
> root = [1, 2, 3], k = 5
> 输出: [[1],[2],[3],[],[]]
> 解释:
>     输入输出各部分都应该是链表，而不是数组。
>     例如, 输入的结点 root 的 val= 1, root.next.val = 2, \root.next.next.val = 3, 且 root.next.next.next = null。
>     第一个输出 output[0] 是 output[0].val = 1, output[0].next = null。
>     最后一个元素 output[4] 为 null, 它代表了最后一个部分为空链表。
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public ListNode[] splitListToParts(ListNode root, int k) {
        int n = 0;
        for (ListNode p = root; p != null; p = p.next) n++;
        ListNode cur = root;
        int len = n / k, rest = n % k;
        ListNode[] ans = new ListNode[k];
        for (int i = 0; i < k; ++i) {
            ans[i] = cur;
            ListNode p = new ListNode(-1), q = p;
            for (int j = 0; j < len + (i < rest ? 1 : 0) - 1; ++j) {
                if (cur != null) cur = cur.next;
            }
            if (cur == null) break;
            ListNode next = cur.next;
            cur.next = null;
            cur = next;
        }
        return ans;
    }
}
```

# 二叉树

## 二叉树的遍历

### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)

> ```
> 输入：root = [1,null,2,3]
> 输出：[1,2,3]
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) return ans;
        Stack<TreeNode> stk = new Stack<>();
        while (!stk.isEmpty() || root != null) {
            while (root != null) {
                ans.add(root.val); 
                stk.push(root);
                root = root.left;
            }
            root = stk.pop();
            root = root.right;
        } 
        return ans;
    }
}
```

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

> ```
> 输入：root = [1,null,2,3]
> 输出：[1,3,2]
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) return ans;
        Stack<TreeNode> stk = new Stack<>();
        while (!stk.isEmpty() || root != null) {
            while (root != null) {
                stk.push(root);
                root = root.left;
            }
            root = stk.pop();
            ans.add(root.val);
            root = root.right;
        }
        return ans;
    }
}
```

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

> ```
> 输入: [1,null,2,3]  
>    1
>     \
>      2
>     /
>    3 
> 
> 输出: [3,2,1]
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) return ans;
        Stack<TreeNode> stk = new Stack<>();
        TreeNode lastNode = null;
        while (!stk.isEmpty() || root != null) {
            while (root != null) {
                stk.push(root);
                root = root.left;
            }
            root = stk.peek();
            if (root.right == null || root.right == lastNode) {
                stk.pop();
                ans.add(root.val);
                lastNode = root;
                root = null;
            } else root = root.right;
        }
        return ans;
    }
}
```

### [剑指 Offer 33. 二叉搜索树的后序遍历序列](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/)

> ```
> 输入: [1,6,3,2,5]
> 输出: false
>      5
>     / \
>    2   6
>   / \
>  1   3
> ```

```java
class Solution {
    public boolean verifyPostorder(int[] postorder) {
        return dfs(postorder, 0, postorder.length - 1);
    }

    public boolean dfs(int[] postorder, int l, int r) {
        if (l >= r) return true;
        int root = postorder[r];
        int k = l;
        while (postorder[k] < root) k++;
        int t = k;
        while (postorder[k] > root) k++;
        return k == r & dfs(postorder, l, t - 1) && dfs(postorder, t, r - 1);
    }
}
```

### [剑指 Offer 32 - I. 从上到下打印二叉树](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/)

> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> [3,9,20,15,7]
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public int[] levelOrder(TreeNode root) {
        List<Integer> ans = new ArrayList<>();
        if (root == null) return new int[]{};
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode t = queue.poll();
            ans.add(t.val);
            if (t.left != null) queue.offer(t.left);
            if (t.right != null) queue.offer(t.right);
        }
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }
}
```

### [剑指 Offer 32 - III. 从上到下打印二叉树 III](https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/)

> ```
>     3
>    / \
>   9  20
>     /  \
>    15   7
> [
>   [3],
>   [20,9],
>   [15,7]
> ]
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> ans = new ArrayList<>();
        if (root == null) return ans;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        boolean flag = false;
        while (!queue.isEmpty()) {
            int size = queue.size();
            Deque<Integer> level = new LinkedList<>();
            while (size-- > 0) {
                TreeNode t = queue.poll();
                if (flag) level.offerFirst(t.val);
                else level.offerLast(t.val);
                if (t.left != null) queue.offer(t.left);
                if (t.right != null) queue.offer(t.right);
            }
            ans.add(new ArrayList<>(level));
            flag = !flag;
        }
        return ans;
    }
}
```

## 构造二叉树

### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

> ```
> 输入：前序遍历 preorder = [3,9,20,15,7]
> 	 中序遍历 inorder = [9,3,15,20,7]
> 输出：
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    HashMap<Integer, Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for (int i = 0; i < inorder.length; ++i) map.put(inorder[i], i);
        return build(preorder, 0, preorder.length - 1, inorder, 0, inorder.length - 1);
    }

    public TreeNode build(int[] preorder, int pl, int pr, int[] inorder, int il, int ir) {
        if (pl > pr) return null;
        int k = map.get(preorder[pl]);
        TreeNode root = new TreeNode(preorder[pl]);
        root.left = build(preorder, pl + 1, pl + k - il , inorder, il, k - 1);
        root.right = build(preorder, pl + k - il + 1, pr, inorder, k + 1, ir);
        return root;
    }
}
```

### [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

> ```
> 输入：中序遍历 inorder = [9,3,15,20,7]
>  	 后序遍历 postorder = [9,15,7,20,3]
> 输出：
>     3
>    / \
>   9  20
>     /  \
>    15   7
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    HashMap<Integer, Integer> map = new HashMap<>();
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        for (int i = 0; i < inorder.length; ++i) map.put(inorder[i], i);
        return build(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);
    }

    public TreeNode build(int[] inorder, int il, int ir, int[] postorder, int pl, int pr) {
        if (il > ir) return null;
        TreeNode root = new TreeNode(postorder[pr]);
        int k = map.get(postorder[pr]);
        root.left = build(inorder, il, k - 1, postorder, pl, pl + k - il - 1);
        root.right = build(inorder, k + 1, ir, postorder, pl + k - il, pr - 1);
        return root;
    }
}
```

### [889. 根据前序和后序遍历构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

> ```
> 输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]
> 输出：[1,2,3,4,5,6,7]
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    HashMap<Integer, Integer> map = new HashMap<>();
    public TreeNode constructFromPrePost(int[] pre, int[] post) {
        for (int i = 0; i < post.length; ++i) map.put(post[i], i);
        return build(pre, 0, pre.length - 1, post, 0);
    }

    public TreeNode build(int[] pre, int pl, int pr, int[] post, int ql) {
        if (pl > pr) return null;
        TreeNode root = new TreeNode(pre[pl]);
        if (pl < pr) {
            int leftv = pre[pl + 1];
            int cnt = map.get(leftv) - ql + 1;
            root.left = build(pre, pl + 1, pl + cnt, post, ql);
            root.right = build(pre, pl + cnt + 1, pr, post, ql + cnt);
        }
        return root;
    }
}

```

### [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

> ```
> 输入：nums = [-10,-3,0,5,9]
> 输出：[0,-3,9,-10,null,5]
> 解释：[0,-10,5,null,-3,null,9]
> ```
>
> ![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return dfs(nums, 0, nums.length - 1);
    }

    public TreeNode dfs(int[] nums, int l, int r) {
        if (l > r) return null;
        int mid = l + r >> 1;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = dfs(nums, l, mid - 1);
        root.right = dfs(nums, mid + 1, r);
        return root;
    }
}
```

### [109. 有序链表转换二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/)

> ```
> 给定的有序链表： [-10, -3, 0, 5, 9],
> 
> 一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：
> 
>       0
>      / \
>    -3   9
>    /   /
>  -10  5
> ```

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode sortedListToBST(ListNode head) {
        if (head == null) return null;
        else if (head.next == null) return new TreeNode(head.val);
        
        ListNode slow = head, fast = head;
        ListNode pre = null;
        while (fast != null && fast.next != null) {
            pre = slow;
            slow = slow.next;
            fast = fast.next.next;
        }

        TreeNode root = new TreeNode(slow.val);
        pre.next = null;

        root.left = sortedListToBST(head);
        root.right = sortedListToBST(slow.next);
        return root;
    }

}
```

### [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

> ```
> 输入：root = [1,2,5,3,4,null,6]
> 输出：[1,null,2,null,3,null,4,null,5,null,6]
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        Stack<TreeNode> stk = new Stack<>();
        stk.push(root);
        TreeNode prev = null;
        while (!stk.isEmpty()) {
            TreeNode cur = stk.pop();
            if (prev != null) {
                prev.left = null;
                prev.right = cur;
            }
            if (cur.right != null) stk.push(cur.right);
            if (cur.left != null) stk.push(cur.left);
            prev = cur;
        }
    }
}
```

### [剑指 Offer 37. 序列化二叉树](https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/)

> ```
> 你可以将以下二叉树：
> 
>     1
>    / \
>   2   3
>      / \
>     4   5
> 
> 序列化为 "[1,2,3,null,null,4,5]"
> ```

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "[]";
        StringBuilder sb = new StringBuilder("[");
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode t = queue.poll();
            if (t != null) {
                sb.append(t.val + ",");
                queue.offer(t.left);
                queue.offer(t.right);
            } else sb.append("null,");
        }
        sb.deleteCharAt(sb.length() - 1);
        sb.append("]");
        return sb.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        if (data.equals("[]")) return null;
        String[] val = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(val[0]));
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int idx = 1;
        while (!queue.isEmpty()) {
            TreeNode t = queue.poll();
            if (!val[idx].equals("null")) {
                t.left = new TreeNode(Integer.parseInt(val[idx]));
                queue.offer(t.left);
            }
            idx++;
            if (!val[idx].equals("null")) {
                t.right = new TreeNode(Integer.parseInt(val[idx]));
                queue.offer(t.right);
            }
            idx++;
        }
        return root;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

## 验证二叉树

### [100. 相同的树](https://leetcode-cn.com/problems/same-tree/)

> ```
> 输入：p = [1,2,3], q = [1,2,3]
> 输出：true
> ```
>
> ![img](https://assets.leetcode.com/uploads/2020/12/20/ex1.jpg)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q != null || p != null && q == null) return false;
        if (p == null && q == null) return true;
        if (p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }
}
```

### [剑指 Offer 28. 对称的二叉树](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)

> ```
> 输入：root = [1,2,2,3,4,4,3]
> 输出：true
> ```

```java
 /**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return isSameTree(root.left, root.right);
    }

    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null && q != null || p != null && q == null) return false;
        if (p.val != q.val) return false;
        return isSameTree(p.left, q.right) && isSameTree(q.left, p.right);
    }
}
```

















