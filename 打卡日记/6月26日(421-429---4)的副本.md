### [815. 公交路线](https://leetcode-cn.com/problems/bus-routes/)

* 将每个公交路线看作一个点，公共路线看作边，构建无向图
* 存储每个点上有哪些公交路线
* 遍历完当前点后将其从哈希表中删除

```java
class Solution {
    public int numBusesToDestination(int[][] routes, int source, int target) {
        if (source == target) return 0;
        int n = routes.length;
        HashMap<Integer, List<Integer>> g = new HashMap<>();
        int[] dist = new int[n];
        Arrays.fill(dist, 1000000);
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; ++i) {
            for (int x: routes[i]) {
                if (x == source) {
                    dist[i] = 1;
                    queue.offer(i);
                }
                g.computeIfAbsent(x, l -> new ArrayList<>()).add(i);
            }
        }
        while (!queue.isEmpty()) {
            int t = queue.poll();
            for (int x: routes[t]) {
                if (x == target) return dist[t];
                if (g.get(x) != null) {
                    for (int y: g.get(x)) {
                        if (dist[y] > dist[t] + 1) {
                            dist[y] = dist[t] + 1;
                            queue.offer(y);
                        }
                    }
                }
                g.remove(x);
            }
        }
        return -1;
    }
}
```

### [433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)

```java
class Solution {
    public int minMutation(String start, String end, String[] bank) {
        Set<String> set = new HashSet<>();
        for (String s: bank) set.add(s);
        Map<String, Integer> dist = new HashMap<>();
        Queue<String> queue = new LinkedList<>();
        queue.offer(start);
        dist.put(start, 0);
        char[] chars = {'A', 'T', 'C', 'G'};
        while (!queue.isEmpty()) {
            String t = queue.poll();
            if (t.equals(end)) return dist.get(end);
            char[] ch = t.toCharArray();
            for (int i = 0; i < t.length(); ++i) {
                char tmp = ch[i];
                for (Character c: chars) {
                    if (ch[i] == c) continue;
                    ch[i] = c;
                    String key = new String(ch);
                    if (!set.contains(key)) continue;
                    if (!dist.containsKey(key)) {
                        dist.put(key, dist.get(t) + 1);
                        queue.offer(key);
                    }
                }
                ch[i] = tmp;
            }
        }
        return -1;
    }
}
```

### [434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)

```java
class Solution {
    public int countSegments(String s) {
        String trimmed = s.trim();
        if (trimmed.equals("")) {
            return 0;
        }
        return trimmed.split("\\s+").length;
    }
}
```

### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)

* 贪心法
* 对区间按照右端点从小到大排序，对其进行遍历，维护上一个区间的右端点
* 如果当前区间左端点与上一区间不重合，则更新区间

```java
class Solution {
    public int eraseOverlapIntervals(int[][] intervals) {
        int n = intervals.length;
        if (n == 0 || intervals == null) return 0;
        Arrays.sort(intervals, (a, b)->(a[1] - b[1]));
        int ans = 1, r = intervals[0][1];
        for (int i = 1; i < n; ++i) {
            if (intervals[i][0] >= r) {
                ans++;
                r = intervals[i][1];
            }
        }        
        return n - ans;
    }
}
```

### [436. 寻找右区间](https://leetcode-cn.com/problems/find-right-interval/)

* 排序 + 二分

```java
class Solution {
    public int[] findRightInterval(int[][] intervals) {
        int n = intervals.length;
        Map<int[], Integer> map = new HashMap<>();
        for (int i = 0; i < n; ++i) map.put(intervals[i], i);
        Arrays.sort(intervals, (o1,o2) -> o1[0]-o2[0]);
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        for (int i = 0; i < n; ++i) {
            int l = 0, r = n - 1;
            while (l < r) {
                int mid = l + r >> 1;
                if (intervals[mid][0] >= intervals[i][1]) r = mid;
                else l = mid + 1;
            }
            if (intervals[l][0] >= intervals[i][1]) ans[map.get(intervals[i])] = map.get(intervals[l]);
        }
        return ans;
    }
}
```

### [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

```java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();

    public int pathSum(TreeNode root, int targetSum) {
        map.put(0, 1);
        return dfs(root, 0, targetSum);
    }

    public int dfs(TreeNode root, int curSum, int targetSum) {
        if (root == null) return 0;
        int ans = 0;
        curSum += root.val;
        ans += map.getOrDefault(curSum - targetSum, 0);
        map.put(curSum, map.getOrDefault(curSum, 0) + 1);
        int left = dfs(root.left, curSum, targetSum);
        int right = dfs(root.right, curSum, targetSum);
        ans += left + right;
        map.put(curSum, map.get(curSum) - 1);
        return ans;
    }
}
```



























