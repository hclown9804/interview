### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

![](https://i.loli.net/2021/06/16/sAnGN9qw2d3o5Bf.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;
        int[][] f = new int[n][3];
        for (int i = 0; i < n; ++i) Arrays.fill(f[i], Integer.MIN_VALUE);
        f[0][1] = -prices[0];
        f[0][0] = 0;
        for (int i = 1; i < n; ++i) {
            f[i][0] = Math.max(f[i - 1][0], f[i - 1][2]);
            f[i][1] = Math.max(f[i - 1][1], f[i - 1][0] - prices[i]);
            f[i][2] = f[i - 1][1] + prices[i];
        }
        return Math.max(f[n - 1][0], Math.max(f[n - 1][1], f[n - 1][2]));
    }
}
```

### [310. 最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> ans = new ArrayList<>();
        if (n == 1) return new ArrayList<>(Arrays.asList(0));
        int[] degree = new int[n];
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i < n; ++i) tree.add(new ArrayList<>());
        for (int[] edge: edges) {
            degree[edge[0]]++;
            degree[edge[1]]++;
            tree.get(edge[0]).add(edge[1]);
            tree.get(edge[1]).add(edge[0]);
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; ++i) {
            if (degree[i] == 1) queue.offer(i);
        }
        while (!queue.isEmpty()) {
            ans = new ArrayList<>();
            int size = queue.size();
            while (size-- > 0) {
                int cur = queue.poll();
                ans.add(cur);
                List<Integer> tmp = tree.get(cur);
                for (int t: tmp) {
                    degree[t]--;
                    if (degree[t] == 1) queue.offer(t);
                }
            }
        }
        return ans;
    }
}
```

### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

* 区间DP

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[] a = new int[n + 2];
        Arrays.fill(a, 1);
        for (int i = 1; i <= n; ++i) a[i] = nums[i - 1];
        int[][] f = new int[n + 2][n + 2];
        for (int len = 3; len <= n + 2; ++len) {
            for (int i = 0; i + len - 1 <= n + 1; ++i) {
                int j = i + len - 1;
                for (int k = i + 1; k < j; ++k) {
                    f[i][j] = Math.max(f[i][j], f[i][k] + f[k][j] + a[i] * a[j] * a[k]);
                }
            }
        }
        return f[0][n + 1];
    }
}
```

### [313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)

* 类似丑数II，将  $primes$ 中的所有数归并；
* 使用小根堆存储数字和小标的乘积与对应下标。

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b)->(a[0] - b[0]));
        for (int x: primes) heap.offer(new int[]{x, 0});
        int[] q = new int[n];
        q[0] = 1;
        for (int i = 1; i < n; ) {
            int[] p = heap.poll();
            if (p[0] != q[i - 1]) q[i++] = p[0];
            int prime = p[0] / q[p[1]];
            heap.offer(new int[]{prime * q[p[1] + 1], p[1] + 1});
        }
        return q[n - 1];
    }
}
```



