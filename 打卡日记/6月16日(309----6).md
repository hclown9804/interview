### [309. 最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

![](https://i.loli.net/2021/06/16/sAnGN9qw2d3o5Bf.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int n = prices.length;
        if (n == 0) return 0;
        int[][] f = new int[n][3];
        for (int i = 0; i < n; ++i) Arrays.fill(f[i], Integer.MIN_VALUE);
        f[0][1] = -prices[0];
        f[0][0] = 0;
        for (int i = 1; i < n; ++i) {
            f[i][0] = Math.max(f[i - 1][0], f[i - 1][2]);
            f[i][1] = Math.max(f[i - 1][1], f[i - 1][0] - prices[i]);
            f[i][2] = f[i - 1][1] + prices[i];
        }
        return Math.max(f[n - 1][0], Math.max(f[n - 1][1], f[n - 1][2]));
    }
}
```

### [310. 最小高度树](https://leetcode-cn.com/problems/minimum-height-trees/)

```java
class Solution {
    public List<Integer> findMinHeightTrees(int n, int[][] edges) {
        List<Integer> ans = new ArrayList<>();
        if (n == 1) return new ArrayList<>(Arrays.asList(0));
        int[] degree = new int[n];
        List<List<Integer>> tree = new ArrayList<>();
        for (int i = 0; i < n; ++i) tree.add(new ArrayList<>());
        for (int[] edge: edges) {
            degree[edge[0]]++;
            degree[edge[1]]++;
            tree.get(edge[0]).add(edge[1]);
            tree.get(edge[1]).add(edge[0]);
        }
        Queue<Integer> queue = new LinkedList<>();
        for (int i = 0; i < n; ++i) {
            if (degree[i] == 1) queue.offer(i);
        }
        while (!queue.isEmpty()) {
            ans = new ArrayList<>();
            int size = queue.size();
            while (size-- > 0) {
                int cur = queue.poll();
                ans.add(cur);
                List<Integer> tmp = tree.get(cur);
                for (int t: tmp) {
                    degree[t]--;
                    if (degree[t] == 1) queue.offer(t);
                }
            }
        }
        return ans;
    }
}
```

### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

* 区间DP

```java
class Solution {
    public int maxCoins(int[] nums) {
        int n = nums.length;
        int[] a = new int[n + 2];
        Arrays.fill(a, 1);
        for (int i = 1; i <= n; ++i) a[i] = nums[i - 1];
        int[][] f = new int[n + 2][n + 2];
        for (int len = 3; len <= n + 2; ++len) {
            for (int i = 0; i + len - 1 <= n + 1; ++i) {
                int j = i + len - 1;
                for (int k = i + 1; k < j; ++k) {
                    f[i][j] = Math.max(f[i][j], f[i][k] + f[k][j] + a[i] * a[j] * a[k]);
                }
            }
        }
        return f[0][n + 1];
    }
}
```

### [313. 超级丑数](https://leetcode-cn.com/problems/super-ugly-number/)

* 类似丑数II，将  $primes$ 中的所有数归并；
* 使用小根堆存储数字和小标的乘积与对应下标。

```java
class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b)->(a[0] - b[0]));
        for (int x: primes) heap.offer(new int[]{x, 0});
        int[] q = new int[n];
        q[0] = 1;
        for (int i = 1; i < n; ) {
            int[] p = heap.poll();
            if (p[0] != q[i - 1]) q[i++] = p[0];
            int prime = p[0] / q[p[1]];
            heap.offer(new int[]{prime * q[p[1] + 1], p[1] + 1});
        }
        return q[n - 1];
    }
}
```

### [315. 计算右侧小于当前元素的个数](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

* 树状数组

```java
class Solution {
    int n = 20001;
    int[] tr = new int[n + 1];
    public List<Integer> countSmaller(int[] nums) {
        List<Integer> ans = new ArrayList<>();
        for (int i = nums.length - 1; i >= 0; --i) {
            int x = nums[i] + 10001;
            ans.add(query(x - 1));
            add(x, 1);
        }
        Collections.reverse(ans);
        return ans;
    }

    public int lowbit(int x) {
        return x & -x;
    }

    public int query(int x) {
        int ans = 0;
        for (int i = x; i > 0; i -= lowbit(i)) ans += tr[i];
        return ans;
    }

    public void add(int x, int v) {
        for (int i = x; i <= n; i += lowbit(i)) tr[i] += v;
    }
}
```

### [316. 去除重复字母](https://leetcode-cn.com/problems/remove-duplicate-letters/)

* 贪心
* 从前往后扫描，每次判断答案的最后一个字母字母序更大且在后面出现即可删除。

```java
class Solution {
    public String removeDuplicateLetters(String s) {
        char[] str = s.toCharArray();
        int n = s.length();
        char[] stk = new char[n];

        boolean[] st = new boolean[128];
        int[] last = new int[128];

        for (int i = 0; i < n; ++i) last[str[i]] = i;
        int idx = -1;
        for (int i = 0; i < n; ++i) {
            if (st[str[i]]) continue;
            while (idx >= 0 && stk[idx] > str[i] && last[stk[idx]] > i) st[stk[idx--]] = false;
            st[str[i]] = true;
            stk[++idx] = str[i];
        }
        return new String(stk, 0, idx + 1);
    }
}
```





