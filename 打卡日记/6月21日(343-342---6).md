### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

* 尽可能分成 3 和 2，最多只能有两个2

* $n=a_1+a_2+...+a_i$

  * 不可能存在 $a_i>=5$，$a_i=3+(a_i-3)$，则 $3(a_i-3)=3a_i-9>a_i$；
  * 不包含 1；
  * $a_i=4=2+2$；
  * 则只包含 2 和 3；
  * $2+2+2=6=3+3$ ；

  ```java
  class Solution {
      public int integerBreak(int n) {
          if (n <= 3) return 1 * (n - 1);
          int p = 1;
          while (n >= 5) {
              n -= 3;
              p *= 3;
          }
          return p * n;
      }
  }
  ```

### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```java
class Solution {
    public void reverseString(char[] s) {
        int i = 0, j = s.length - 1;
        while (i < j) {
            swap(s, i, j);
            i++;
            j--;
        }
    }

    public void swap(char[] s, int i, int j) {
        char t = s[i];
        s[i] = s[j];
        s[j] = t;
    }
}
```

### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

```java
class Solution {
    public String reverseVowels(String s) {
        int i = 0, j = s.length() - 1;
        char[] str = s.toCharArray();
        while (i < j) {
            if (!check(str[i])) i++;
            else if (!check(str[j])) j--;
            else if (check(str[i]) && check(str[j])) {
                swap(str, i, j);
                i++;
                j--;
            }
        }
        return String.valueOf(str);
    }

    public boolean check(char c) {
        if (c == 'A' || c == 'a' || c == 'e' || c == 'E' || c == 'i' || c == 'I' || c == 'o' ||  c == 'O' || c == 'u' || c == 'U') return true;
        return false;
    }

    public void swap(char[] s, int i, int j) {
        char t = s[i];
        s[i] = s[j];
        s[j] = t;
    }
}
```

### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int n = nums.length;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < n; ++i) {
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        }
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b)->(b[1]-a[1]));
        for (int key: map.keySet()) {
            heap.offer(new int[]{key, map.get(key)});
        }
        int[] ans = new int[k];
        int idx = 0;
        while (k-- > 0) {
            int t = heap.poll()[0];
            ans[idx++] = t;
        }
        return ans;
    }
}
```



