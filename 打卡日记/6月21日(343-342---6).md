### [343. 整数拆分](https://leetcode-cn.com/problems/integer-break/)

* 尽可能分成 3 和 2，最多只能有两个2

* $n=a_1+a_2+...+a_i$

  * 不可能存在 $a_i>=5$，$a_i=3+(a_i-3)$，则 $3(a_i-3)=3a_i-9>a_i$；
  * 不包含 1；
  * $a_i=4=2+2$；
  * 则只包含 2 和 3；
  * $2+2+2=6=3+3$ ；

  ```java
  class Solution {
      public int integerBreak(int n) {
          if (n <= 3) return 1 * (n - 1);
          int p = 1;
          while (n >= 5) {
              n -= 3;
              p *= 3;
          }
          return p * n;
      }
  }
  ```

### [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)

```java
class Solution {
    public void reverseString(char[] s) {
        int i = 0, j = s.length - 1;
        while (i < j) {
            swap(s, i, j);
            i++;
            j--;
        }
    }

    public void swap(char[] s, int i, int j) {
        char t = s[i];
        s[i] = s[j];
        s[j] = t;
    }
}
```

### [345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)

```java
class Solution {
    public String reverseVowels(String s) {
        int i = 0, j = s.length() - 1;
        char[] str = s.toCharArray();
        while (i < j) {
            if (!check(str[i])) i++;
            else if (!check(str[j])) j--;
            else if (check(str[i]) && check(str[j])) {
                swap(str, i, j);
                i++;
                j--;
            }
        }
        return String.valueOf(str);
    }

    public boolean check(char c) {
        if (c == 'A' || c == 'a' || c == 'e' || c == 'E' || c == 'i' || c == 'I' || c == 'o' ||  c == 'O' || c == 'u' || c == 'U') return true;
        return false;
    }

    public void swap(char[] s, int i, int j) {
        char t = s[i];
        s[i] = s[j];
        s[j] = t;
    }
}
```

### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {
        int n = nums.length;
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < n; ++i) {
            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);
        }
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b)->(b[1]-a[1]));
        for (int key: map.keySet()) {
            heap.offer(new int[]{key, map.get(key)});
        }
        int[] ans = new int[k];
        int idx = 0;
        while (k-- > 0) {
            int t = heap.poll()[0];
            ans[idx++] = t;
        }
        return ans;
    }
}
```

### [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        int n = nums1.length, m = nums2.length;
        int[] ans = new int[n + m];
        int i = 0, j = 0, k = 0;
        while (i < n && j < m) {
            if (nums1[i] == nums2[j]) {
                if (k == 0 || nums1[i] != ans[k - 1]) ans[k++] = nums1[i];
                i++;
                j++;
            } else if (nums1[i] < nums2[j]) i++;
            else j++;
        }
        return Arrays.copyOfRange(ans, 0, k);
    }
}
```

### [352. 将数据流变为多个不相交区间](https://leetcode-cn.com/problems/data-stream-as-disjoint-intervals/)

```java
class SummaryRanges {
    int INF = 0x3f3f3f3f;
    TreeSet<int[]> set;
    /** Initialize your data structure here. */
    public SummaryRanges() {
        set = new TreeSet<>((o1, o2)->{
            if (o1[0] != o2[0]) return o1[0] - o2[0];
            return o1[1] - o2[1];
        });
        set.add(new int[]{-INF, -INF});
        set.add(new int[]{INF, INF});
    }
    
    public void addNum(int val) {
        int[] l = set.lower(new int[]{val, INF});
        int[] r = set.higher(new int[]{val, INF});
        if (l[1] >= val) return;
        if (l[1] == val - 1 && r[0] == val + 1) {
            set.add(new int[]{l[0], r[1]});
            set.remove(l);
            set.remove(r);
        } else if (l[1] == val - 1) {
            set.add(new int[]{l[0], val});
            set.remove(l);
        } else if (r[0] == val + 1) {
            set.add(new int[]{val, r[1]});
            set.remove(r);
        } else {
            set.add(new int[]{val, val});
        }
    }
    
    public int[][] getIntervals() {
        int n = set.size();
        int[][] ans = new int[n - 2][2];
        int idx = 0;
        for (int[] arr: set) {
            if (arr[0] == -INF || arr[0] == INF) continue;
            ans[idx][0] = arr[0];
            ans[idx++][1] = arr[1];
        }
        return ans;
    }
}
```

### [354. 俄罗斯套娃信封问题](https://leetcode-cn.com/problems/russian-doll-envelopes/)

```java
class Solution {
    public int maxEnvelopes(int[][] envelopes) {
        int n = envelopes.length;
        int[] f = new int[n];
        int ans = 0;
        Arrays.sort(envelopes, (a, b)->(a[0]-b[0]));
        for (int i = 0; i < n; ++i) {
            f[i] = 1;
            for (int j = 0; j < n; ++j) {
                if (envelopes[j][0] < envelopes[i][0] && envelopes[j][1] < envelopes[i][1]) {
                    f[i] = Math.max(f[i], f[j] + 1);
                }
            }
            ans = Math.max(ans, f[i]);
        }
        return ans;
    }
}
```



