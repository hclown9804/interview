### [367. 有效的完全平方数](https://leetcode-cn.com/problems/valid-perfect-square/)

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int l = 1, r = num;
        while (l < r) {
            int mid = l + r >> 1;
            if (mid >= num / mid) r = mid;
            else l = mid + 1;
        }
        return r * r == num;
    }
}
```

### [368. 最大整除子集](https://leetcode-cn.com/problems/largest-divisible-subset/)

* 思路类似 $LIS$ 问题，但是需要求具体方案而不是方案数

```java
class Solution {
    public List<Integer> largestDivisibleSubset(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        int[] f = new int[n];
        int k = 0;
        for (int i = 0; i < n; ++i) {
            f[i] = 1;
            for (int j = 0; j < i; ++j) {
                if (nums[i] % nums[j] == 0) f[i] = Math.max(f[i], f[j] + 1);
            }
            if (f[k] < f[i]) k = i;
        }
        List<Integer> ans = new ArrayList<>();
        ans.add(nums[k]);
        while (f[k] > 1) {
            for (int i = 0; i < k; ++i) {
                if (nums[k] % nums[i] == 0 && f[k] == f[i] + 1) {
                    ans.add(nums[i]);
                    k = i;
                    break;
                }
            }
        }
        return ans;
    }
}
```

### [371. 两整数之和](https://leetcode-cn.com/problems/sum-of-two-integers/)

```java
class Solution {
    public int getSum(int a, int b) {
        if (a == 0) return b;
        int sum = a ^ b, carray = (a & b) << 1;
        return getSum(carray, sum);
    }
}
```

### [372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

```java
class Solution {
    int p = 1337;

    int qmi(int a, int b) {
        a %= p;
        int ans = 1;
        while (b != 0) {
            if ((b & 1) != 0) ans = ans * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return ans;
    }

    public int superPow(int a, int[] b) {
        if (b.length == 0) return 1;
        return pow(a, b, b.length - 1);
    }

    public int pow(int a, int[] b, int idx) {
        if (idx < 0) return 1;
        int k = b[idx--];
        int sp = pow(a, b, idx);
        return qmi(sp, 10) * qmi(a, k) % p;
    }
}
```

### [373. 查找和最小的K对数字](https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/)

```java
class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> ans = new ArrayList<>();
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b)->(a[0] - b[0]));
        if (nums1.length == 0 || nums2.length == 0) return ans;
        for (int i = 0; i < Math.min(k, nums2.length); ++i) {
            heap.add(new int[]{nums1[0] + nums2[i], 0, i});
        }
        while (ans.size() < k && heap.size() > 0) {
            int[] t = heap.poll();
            List<Integer> cur = new ArrayList<>();
            cur.add(nums1[t[1]]);
            cur.add(nums2[t[2]]);
            ans.add(cur);
            if (t[1] + 1 < nums1.length) heap.add(new int[]{nums1[t[1] + 1] + nums2[t[2]], t[1] + 1, t[2]});
        }
        return ans;
    }
}
```

### [374. 猜数字大小](https://leetcode-cn.com/problems/guess-number-higher-or-lower/)

```java
public class Solution extends GuessGame {
    public int guessNumber(int n) {
        int l = 1, r = n;
        while (l < r) {
            int mid = l + r >>> 1;
            if (guess(mid) <= 0) r = mid;
            else l = mid + 1;
        }
        return r;
    }
}
```







