### [406. 根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

* 先排序再插入
* 先按照 H 高度降序，K 个数升序排序
* 遍历排序后的数组，根据 K 插入到 K 的位置上

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b)->{
            if (a[0] == b[0]) return a[1] - b[1];
            return b[0] - a[0];
        });
        List<int[]> ans = new ArrayList<>();
        for (int[] p: people) ans.add(p[1], p);
        return ans.toArray(new int[0][0]);
    }
}
```

### [407. 接雨水 II](https://leetcode-cn.com/problems/trapping-rain-water-ii/)

* $f[i,j]$ 表示每个格子的最终高度；
* 从 $(i,j)$ 到每个边界的每条路径的最大值的最小值；

```java
class Cell {
    int row, col, height;
    public Cell(int row, int col, int height) {
        this.row = row;
        this.col = col;
        this.height = height;
    }
}

class Solution {
    public int trapRainWater(int[][] heightMap) {
        int n = heightMap.length, m = heightMap[0].length;
        if (heightMap == null || n == 0 || m == 0) return 0;
        boolean[][] st = new boolean[n][m];
        PriorityQueue<Cell> heap = new PriorityQueue<>((a, b)->(a.height - b.height));
        for (int i = 0; i < n; ++i) {
            st[i][0] = st[i][m - 1] = true;
            heap.offer(new Cell(i, 0, heightMap[i][0]));
            heap.offer(new Cell(i, m - 1, heightMap[i][m - 1]));
        }
        for (int i = 0; i < m; ++i) {
            st[0][i] = st[n - 1][i] = true;
            heap.offer(new Cell(0, i, heightMap[0][i]));
            heap.offer(new Cell(n - 1, i, heightMap[n - 1][i]));
        }
        int[] dx = {-1, 0, 1, 0}, dy = {0, 1, 0, -1};
        int ans = 0;
        while (!heap.isEmpty()) {
            Cell cell = heap.poll();
            for (int i = 0; i < 4; ++i) {
                int a = cell.row + dx[i], b = cell.col + dy[i];
                if (a >= 0 && a < n && b >= 0 && b < m && !st[a][b]) {
                    st[a][b] = true;
                    ans += Math.max(0, cell.height - heightMap[a][b]);
                    heap.offer(new Cell(a, b, Math.max(heightMap[a][b], cell.height)));
                }
            }
        }
        return ans;
    }
}
```

### [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

```java
class Solution {
    public int longestPalindrome(String s) {
        int[] hash = new int[128];
        for (Character c: s.toCharArray()) hash[c]++;
        int ans = 0;
        for (int i = 0; i < 128; ++i) ans += hash[i] / 2 * 2;
        if (ans < s.length()) ans++;
        return ans;
    }
}
```

### [410. 分割数组的最大值](https://leetcode-cn.com/problems/split-array-largest-sum/)

* 二分 + 贪心
* 判断是否有一种划分方案使每一段小于等于 $mid$ 最少能分成多少段

```java
class Solution {
    public int splitArray(int[] nums, int m) {
        int l = 0, r = Integer.MAX_VALUE;
        while (l < r) {
            int mid = l + r >> 1;
            if (check(nums, m, mid)) r = mid;
            else l = mid + 1;
        }
        return r;
    }

    public boolean check(int[] nums, int m, int mid) {
        int sum = 0, cnt = 0;
        for (Integer x: nums) {
            if (x > mid) return false;
            if (sum + x > mid) {
                cnt++;
                sum = x;
            } else sum += x;
        }
        if (sum != 0) cnt++;
        return cnt <= m;
    }
}
```































