### [498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)

* https://www.acwing.com/solution/content/41821/

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int n = mat.length, m = mat[0].length;
        int[] ans = new int[n * m];
        int idx = 0;
        for (int i = 0; i < n + m - 1; ++i) {
            int right_up = Math.max(0, i - m + 1);
            int left_down = Math.min(i, n - 1);
            if (i % 2 == 0) {
                for (int j = left_down; j >= right_up; --j) ans[idx++] = mat[j][i - j];
            } else {
                for (int j = right_up; j <= left_down; ++j) ans[idx++] = mat[j][i - j];
            }
        }
        return ans;
    }
}
```

### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

*  单调栈

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < n * 2; ++i) {
            while (!stack.isEmpty() && nums[i % n] > nums[stack.peekLast()]) ans[stack.pollLast()] = nums[i % n];
            stack.addLast(i % n);
        }
        return ans;
    }
}
```

