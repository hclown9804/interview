### [498. 对角线遍历](https://leetcode-cn.com/problems/diagonal-traverse/)

* https://www.acwing.com/solution/content/41821/

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int n = mat.length, m = mat[0].length;
        int[] ans = new int[n * m];
        int idx = 0;
        for (int i = 0; i < n + m - 1; ++i) {
            int right_up = Math.max(0, i - m + 1);
            int left_down = Math.min(i, n - 1);
            if (i % 2 == 0) {
                for (int j = left_down; j >= right_up; --j) ans[idx++] = mat[j][i - j];
            } else {
                for (int j = right_up; j <= left_down; ++j) ans[idx++] = mat[j][i - j];
            }
        }
        return ans;
    }
}
```

### [503. 下一个更大元素 II](https://leetcode-cn.com/problems/next-greater-element-ii/)

*  单调栈

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] ans = new int[n];
        Arrays.fill(ans, -1);
        Deque<Integer> stack = new LinkedList<>();
        for (int i = 0; i < n * 2; ++i) {
            while (!stack.isEmpty() && nums[i % n] > nums[stack.peekLast()]) ans[stack.pollLast()] = nums[i % n];
            stack.addLast(i % n);
        }
        return ans;
    }
}
```

### [508. 出现次数最多的子树元素和](https://leetcode-cn.com/problems/most-frequent-subtree-sum/)

```java
class Solution {
    Map<Integer, Integer> cnt = new HashMap<>();
    List<Integer> ans = new ArrayList<>();
    int maxc = 0;

    public int[] findFrequentTreeSum(TreeNode root) {
        dfs(root);
        return ans.stream().mapToInt(Integer::valueOf).toArray();
    }

    public int dfs(TreeNode root) {
        if (root == null) return 0;
        int sum = root.val + dfs(root.left) + dfs(root.right);
        cnt.put(sum, cnt.getOrDefault(sum, 0) + 1);
        if (cnt.get(sum) > maxc) {
            maxc = cnt.get(sum);
            ans.clear();
            ans.add(sum);
        } else if (cnt.get(sum) == maxc) ans.add(sum);
        return sum;
    }
}
```

### [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```java
public int findBottomLeftValue(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        int ans = 0;
        while (!queue.isEmpty()) {
            TreeNode cur = queue.poll();
            ans = cur.val;
            if (cur.right != null) queue.offer(cur.right);
            if (cur.left != null) queue.offer(cur.left);
        }
        return ans;
    }
}
```





















